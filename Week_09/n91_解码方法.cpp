//题目条件 'A'~1  ... 'Z'~26
然后给一个数字字符串 计算解码方法的总数。

//类似爬楼梯  理清“如何增加解码方法的”
//由题意 0只能被解读在10 20中

//如果是10 20 则只能唯一解码，一拆就无效了
//如果是 i-1 (10 20) i (20,26]则可以有
	...{[i-1]} {[i]}	= dp[i]    注意dp[i]中i是个数
	...{[i-1][i]}		= dp[i-1]
//其余情况只有dp[i]

int numDecodings(string s) {//非空字符串s
	//爬楼梯
	int n = s.size();
	if(s[0]=='0')return 0;

	vector<int> dp(n+1,0);//前 i个字符的解码方法
	dp[0]=1;    //dp[-1]
	dp[1]=1;    //单字符
	for(int i=1;i<n;i++){
		if(s[i]=='0'){
			if(s[i-1]=='1' || s[i-1]=='2'){
				dp[i+1] = dp[i-1];  //10 20是唯一的 不增加解码方法
			}else 
				return 0;
		}else{
			if(s[i-1]=='1' || (s[i-1]=='2' && s[i]<='6'))//s[i-1]s[i]两位数10~26
				dp[i+1]=dp[i]+dp[i-1];      //可分为 [0~i-1]+单字符 ;[0~i-2]+双字符
			else
				dp[i+1]=dp[i];
		}
	}
	return dp[n];
}